
/*
Explores steps required to enter real numbers
convert them to binary and then reconvert them to strings
Looks at the errors generated by this process.
*/



#include "Project_header.h"

int main (void){ 

char keypress;                                                 
char dp_location;                                                   //Location of decimal point in real number string
int dp_loc;
long LHS_of_dp, RHS_of_dp;
long binary_places;                                                 //Binary equivalent of decimal places
int precision;                                                      //Number of significant binary places
int num_decimal_places;                                             //To be generated by the binary to askii conversion
int LHS_length;
long expt_2,expt_3;

setup_328_HW;                                                       //see header file"
sei();

while(1){
do{Serial.write("F/f    ");}                                        //User prompt; press F or f to escape
while((isCharavailable(127) == 0));                                 //Waits 1 sec for user response; then resends prompt    
keypress = Serial.read();
if ((keypress  == 'F')||
(keypress  == 'f'))break;}


while(1){

Serial.write("\r\n\r\nFPN from keyboard\t");                          //User enters floating point number (FPN)
dp_location = Float_from_KBD(data_buff);                              //Subroutine echoes keypresses to screen

LHS_of_dp = atol(data_buff);                                          //Convert integer part to binary
LHS_length = int_length(LHS_of_dp);
expt_2 = 126 + LHS_length;
LHS_of_dp = LHS_of_dp << (24 - LHS_length);                           //Shift MSB of LHS to bit 23


/********************************/
expt_3 = 0;
dp_loc = dp_location;
while ((data_buff[dp_loc++]) == '0')expt_3 += 1;
Serial.write(expt_3 + '0');
/*******************************/


RHS_of_dp = atol(data_buff + dp_location);                          //Convert the decimal places to an integer number




binary_places = decimal_to_binary(RHS_of_dp, 24, expt_3);                   //Convert the integer number to 24 binary places 

binary_places = (unsigned long)binary_places >> (LHS_length);       //Shift binary places and
LHS_of_dp = LHS_of_dp | binary_places;                              //Merge them with the integer part

LHS_of_dp = LHS_of_dp & (~(0x800000));                              //Clear bit 23: The MSB of the integer number
LHS_of_dp = LHS_of_dp | (expt_2 << 23);                             //Copy in the exponent
Serial.write("FPN equivalent\t");
Binary_to_PC(LHS_of_dp);

Serial.write ("\r\n\r\nReverse the process\r\n");

Serial.write ("\r\nNo. decimal places (Enter 0 - 32)?    ");
Float_from_KBD(data_buff);
num_decimal_places = atol(data_buff);

expt_2 = (((unsigned long)LHS_of_dp >> 23) & 0x1FF) - 127;
ltoa(expt_2, data_buff, 10);


Serial.write("\r\nExponent is  ");
Serial.write(data_buff);
binary_places = LHS_of_dp & (~(0xFF800000));                          //Mask of exponent and sign.
binary_places |= 0x800000;                                            //Reinstate the missing 1

LHS_of_dp = binary_places >> (23 - expt_2);
Serial.write("\r\n\r\nLHS bits are\t");
Binary_to_PC(LHS_of_dp);
Serial.write("  which converts to ");
ltoa(LHS_of_dp, data_buff, 10);
Serial.write(data_buff);


binary_places = binary_places  & (~(LHS_of_dp << (23 - expt_2)));  //23

Serial.write("\r\nRHS bits are\t");
Binary_to_PC(binary_places);



Serial.write("  which converts to 0.");
binary_points_to_decimal(binary_places, expt_2, num_decimal_places);            //All available binary places are to be used

Serial.write("\r\n"); }}





/********************************************************************************************************/
char int_length(long num){
char len = 1;
while (num = (num >> 1)) len += 1;
return len;}



 

/********************************************************************************************************/
void Binary_to_PC(long num){                                              //Sends a binary number to ther screen as ones and zeros
  int HB, LB;                                                             //High byyte and low byte
  
  HB = num >> 16;
  LB = num;
for (int m = 0; m <= 15; m++){if ((m) && !(m%4))Serial.write(' ');
  if (HB & (1 << (15 - m)))Serial.write('1'); else Serial.write('0');}
  Serial.write(' ');
  for (int m = 0; m <= 15; m++){if ((m) && !(m%4))Serial.write(' ');
  if (LB & (1 << (15 - m)))Serial.write('1'); else Serial.write('0');}}
 


/********************************************************************************************************/
long decimal_to_binary(long num,int precision, long expt_3){                         //Takes decimal points as integer number
long denominator = 1;                                                   //converts it to a fraction
long result = 0;                                                        //and converts the fraction to binary places
long remainder;

while(denominator < num) denominator *= 10;
while (expt_3--)denominator *= 10;


remainder = num;
for (int m = 0; m < precision; m++){
result = (result << 1) | ((remainder * 2)/ denominator);
remainder = (remainder * 2) % denominator;}
return result;}



/********************************************************************************************************/
void binary_points_to_decimal(long binary_points, long expt_2, int Num_dps){
long denominator = 1;                                                       
char result;                                                                //Takes the binary places as an integer number
long remainder;                                                             //converts it to a fraction and
                                                                            //converts this to decimal places
denominator = (unsigned long)0x80000000 >> (8 + expt_2);

remainder = binary_points;
for (int m = 0; m < Num_dps; m++){
  result = ((remainder * 10)/ denominator);
remainder = (remainder * 10) % denominator;
Serial.write(result + '0');}}
  


/********************************************************************************************************/
char data_from_KBD(void){
while (!(Serial.available()));
return Serial.read();}
